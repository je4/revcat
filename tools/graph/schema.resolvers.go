package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"encoding/json"
	"fmt"

	emperror "emperror.dev/errors"
	"github.com/je4/revcat/v2/pkg/sourcetype"
	"github.com/je4/revcat/v2/tools/graph/model"
)

// References is the resolver for the references field.
func (r *mediathekEntryResolver) References(ctx context.Context, obj *model.MediathekEntry) ([]*model.MediathekEntry, error) {
	panic(fmt.Errorf("not implemented: References - references"))
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, query string, facets []*model.FacetInput, first *int, after *string, last *int, before *string) (*model.SearchResult, error) {
	panic(fmt.Errorf("xxxnot implemented: Search - search"))
}

// MediathekEntries is the resolver for the mediathekEntries field.
func (r *queryResolver) MediathekEntries(ctx context.Context, signatures []string) ([]*model.MediathekEntry, error) {
	result, err := r.elastic.Mget().Index(r.index).Ids(signatures...).Do(ctx)
	if err != nil {
		return nil, emperror.Wrapf(err, "cannot load '%s' entries %v", r.index, signatures)
	}
	entries := make([]*model.MediathekEntry, 0)
	for _, docInt := range result.Docs {
		doc, ok := docInt.(map[string]interface{})
		if !ok {
			return nil, emperror.Errorf("cannot convert doc %v to map", docInt)
		}
		if found, ok := doc["found"].(bool); !ok || !found {
			return nil, emperror.Errorf("document %s not found", doc["id"])
		}
		id, ok := doc["_id"].(string)
		if !ok {
			return nil, emperror.Errorf("cannot convert doc id %v to string", doc["_id"])
		}
		sourceMap, ok := doc["_source"].(map[string]interface{})
		if !ok {
			return nil, emperror.Errorf("cannot convert doc source %v to map", doc["_source"])
		}
		jsonBytes, err := json.Marshal(sourceMap)
		if err != nil {
			return nil, emperror.Wrapf(err, "cannot marshal source %v", sourceMap)
		}
		source := sourcetype.SourceData{}
		if err := json.Unmarshal(jsonBytes, &source); err != nil {
			return nil, emperror.Wrapf(err, "cannot unmarshal source %v", source)
		}

		entry := &model.MediathekEntry{
			ID:                id,
			Signature:         source.Signature,
			SignatureOriginal: source.SignatureOriginal,
			Source:            source.Source,
			Title:             source.Title,
			Series:            &source.Series,
			Place:             &source.Place,
			Date:              &source.Date,
			Category:          source.Category,
			Tags:              source.Tags,
			Notes:             nil,
			URL:               &source.Url,
			Abstract:          &source.Abstract,
			References:        nil,
			Publisher:         &source.Publisher,
			Rights:            nil,
			License:           nil,
			Type:              nil,
			Extra:             nil,
			Media:             nil,
		}
		entries = append(entries, entry)
		_ = source
		_ = entry
		_ = doc
		_ = id
		/*		if err := doc.Unmarshal(entry); err != nil {

					return nil, errors.Wrapf(err, "cannot unmarshal document %s", doc.Id)
				}
				entries = append(entries, entry)

		*/
	}
	return entries, nil
}

// MediathekEntry returns MediathekEntryResolver implementation.
func (r *Resolver) MediathekEntry() MediathekEntryResolver { return &mediathekEntryResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mediathekEntryResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
