package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"encoding/json"
	"slices"
	"strings"

	emperror "emperror.dev/errors"
	"github.com/elastic/go-elasticsearch/v8/typedapi/core/search"
	"github.com/elastic/go-elasticsearch/v8/typedapi/types"
	"github.com/je4/revcat/v2/pkg/sourcetype"
	"github.com/je4/revcat/v2/tools/graph/model"
)

// ReferencesFull is the resolver for the referencesFull field.
func (r *mediathekFullEntryResolver) ReferencesFull(ctx context.Context, obj *model.MediathekFullEntry) ([]*model.MediathekBaseEntry, error) {
	var result = make([]*model.MediathekBaseEntry, 0)
	var signatures = []string{}
	for _, ref := range obj.Base.References {
		signatures = append(signatures, ref.Signature)
	}
	if len(signatures) == 0 {
		return result, nil
	}
	docs, err := r.loadEntries(ctx, signatures)
	if err != nil {
		return nil, emperror.Wrapf(err, "cannot load entries %v", signatures)
	}
	groups, err := stringsFromContext(ctx, "groups")
	if err != nil {
		return nil, emperror.Wrap(err, "cannot get groups from context")
	}
	var access = make(map[string]bool)
	for _, doc := range docs {
		for t, acls := range doc.ACL {
			for _, group := range groups {
				if slices.Contains(acls, group) {
					access[strings.ToLower(t)] = true
					break
				}
			}
		}
		if ok, found := access["meta"]; ok && found {
			entry := sourceToMediathekBaseEntry(&doc)
			result = append(result, entry)
		}
	}
	return result, nil
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, query string, facets []*model.FacetInput, filter []*model.FilterInput, first *int, after *string, last *int, before *string) (*model.SearchResult, error) {
	groups, err := stringsFromContext(ctx, "groups")
	if err != nil {
		return nil, emperror.Wrap(err, "cannot get groups from context")
	}
	clientName, err := stringFromContext(ctx, "client")
	if err != nil || clientName == "" {
		return nil, emperror.Wrap(err, "cannot get client from context")
	}
	client, ok := r.client[clientName]
	if !ok {
		return nil, emperror.Errorf("client '%s' not found", clientName)
	}

	baseQuery := types.BoolQuery{
		Must:               []types.Query{},
		Should:             []types.Query{},
		MinimumShouldMatch: 1,
	}
	for _, q := range client.AND {
		if q.Field == "" {
			continue
		}
		for _, val := range q.Values {
			baseQuery.Must = append(baseQuery.Must, types.Query{
				Term: map[string]types.TermQuery{
					q.Field: {
						Value: val,
					},
				},
			})
			// baseQuery.Must = append(baseQuery.Must, createFilterQuery(q.Field, val))
		}
	}
	for _, q := range client.OR {
		if q.Field == "" {
			continue
		}
		for _, val := range q.Values {
			baseQuery.Should = append(baseQuery.Should, types.Query{
				Term: map[string]types.TermQuery{
					q.Field: {
						Value: val,
					},
				},
			})
			//			baseQuery.Should = append(baseQuery.Should, createFilterQuery(q.Field, val))
		}
	}
	if len(baseQuery.Should) == 0 {
		baseQuery.MinimumShouldMatch = 0
	}
	aclQuery := types.BoolQuery{
		Must:               []types.Query{},
		Should:             []types.Query{},
		MinimumShouldMatch: 1,
	}
	grps := []string{}
	for _, grp := range client.Groups {
		grps = append(grps, strings.ToLower(grp))
	}
	for _, grp := range groups {
		grps = append(grps, strings.ToLower(grp))
	}
	slices.Sort(grps)
	grps = slices.Compact(grps)
	for _, grp := range grps {
		aclQuery.Must = append(aclQuery.Must, types.Query{
			Term: map[string]types.TermQuery{
				"acl.meta.keyword": {
					Value: grp,
				},
			},
		})
		//		aclQuery.Must = append(aclQuery.Must, createFilterQuery("acl.meta", grp))
	}
	if len(aclQuery.Should) == 0 {
		aclQuery.MinimumShouldMatch = 0
	}

	var esFilter = []types.Query{
		types.Query{Bool: &baseQuery},
		types.Query{Bool: &aclQuery},
	}

	for _, f := range filter {
		for _, val := range f.ValuesString {
			esFilter = append(esFilter, createFilterQuery(f.Field, val))
		}
	}

	resp, err := r.elastic.Search().
		Index(r.index).
		Request(&search.Request{
			Query: &types.Query{
				Bool: &types.BoolQuery{
					Filter: esFilter,
					Must: []types.Query{
						{
							SimpleQueryString: &types.SimpleQueryStringQuery{
								Query: query,
							},
						},
					},
				},
			},
		}).
		Size(25).
		Do(ctx)
	if err != nil {
		return nil, emperror.Wrapf(err, "cannot search for '%s'", query)
	}
	var result = &model.SearchResult{
		TotalCount: int(resp.Hits.Total.Value),
		Edges:      make([]*model.MediathekFullEntry, 0),
		Facets:     make([]*model.Facet, 0),
		PageInfo:   &model.PageInfo{},
	}
	for _, hit := range resp.Hits.Hits {
		source := &sourcetype.SourceData{}
		if err := json.Unmarshal(hit.Source_, source); err != nil {
			return nil, emperror.Wrapf(err, "cannot unmarshal hit %v", hit)
		}
		entry := sourceToMediathekFullEntry(source)
		result.Edges = append(result.Edges, entry)
	}
	return result, nil
}

// MediathekEntries is the resolver for the mediathekEntries field.
func (r *queryResolver) MediathekEntries(ctx context.Context, signatures []string) ([]*model.MediathekFullEntry, error) {
	docs, err := r.loadEntries(ctx, signatures)
	if err != nil {
		return nil, emperror.Wrapf(err, "cannot load entries %v", signatures)
	}

	entries := make([]*model.MediathekFullEntry, 0)
	var access = make(map[string]bool)
	groups, err := stringsFromContext(ctx, "groups")
	if err != nil {
		return nil, emperror.Wrap(err, "cannot get groups from context")
	}
	for _, doc := range docs {
		for t, acls := range doc.ACL {
			for _, group := range groups {
				if slices.Contains(acls, group) {
					access[strings.ToLower(t)] = true
					break
				}
			}
		}
		if ok, found := access["meta"]; ok && found {
			entry := sourceToMediathekFullEntry(&doc)
			entries = append(entries, entry)
		}
	}
	return entries, nil
}

// MediathekFullEntry returns MediathekFullEntryResolver implementation.
func (r *Resolver) MediathekFullEntry() MediathekFullEntryResolver {
	return &mediathekFullEntryResolver{r}
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mediathekFullEntryResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
